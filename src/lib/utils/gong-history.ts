import { prisma } from "@/lib/db";

// Divider line to separate manual notes from auto-generated entries
const AUTO_GENERATED_DIVIDER = "--- Auto-generated from calls ---";

// Date format regex for US format: MM/DD/YYYY
const DATE_REGEX = /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/;

/**
 * Format a Date object or string to US date format (MM/DD/YYYY)
 */
export function formatDateUS(date: Date | string): string {
  const d = typeof date === "string" ? new Date(date) : date;
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  const year = d.getFullYear();
  return `${month}/${day}/${year}`;
}

/**
 * Represents a parsed history entry with date and items
 */
interface HistoryEntry {
  date: string; // MM/DD/YYYY format
  items: string[];
}

/**
 * Result of parsing a history string
 */
interface ParsedHistory {
  manualNotes: string;
  entries: HistoryEntry[];
}

/**
 * Parse a history string into structured format
 * Recognizes date headers (MM/DD/YYYY) followed by bullet points
 * Any text before the divider or unrecognized format is treated as manual notes
 */
export function parseHistoryString(historyText: string | null | undefined): ParsedHistory {
  if (!historyText || historyText.trim() === "") {
    return { manualNotes: "", entries: [] };
  }

  const lines = historyText.split("\n");
  const entries: HistoryEntry[] = [];
  let manualNotes = "";
  let currentEntry: HistoryEntry | null = null;
  let inAutoGeneratedSection = false;
  const manualNotesLines: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmedLine = line.trim();

    // Check for divider
    if (trimmedLine === AUTO_GENERATED_DIVIDER) {
      inAutoGeneratedSection = true;
      continue;
    }

    // If we haven't hit the divider yet, treat as manual notes
    if (!inAutoGeneratedSection) {
      manualNotesLines.push(line);
      continue;
    }

    // Check if this line is a date header
    if (DATE_REGEX.test(trimmedLine)) {
      // Save previous entry if exists
      if (currentEntry) {
        entries.push(currentEntry);
      }
      // Start new entry
      currentEntry = { date: trimmedLine, items: [] };
      continue;
    }

    // Check if this line is a bullet point
    if (currentEntry && trimmedLine.startsWith("-")) {
      const item = trimmedLine.substring(1).trim();
      if (item) {
        currentEntry.items.push(item);
      }
    }
    // Empty lines are ignored
  }

  // Save last entry
  if (currentEntry) {
    entries.push(currentEntry);
  }

  // Clean up manual notes
  manualNotes = manualNotesLines.join("\n").trim();

  return { manualNotes, entries };
}

/**
 * Format structured history entries back into a string
 */
export function formatHistoryEntries(
  manualNotes: string,
  entries: HistoryEntry[]
): string {
  const parts: string[] = [];

  // Add manual notes if present
  if (manualNotes && manualNotes.trim()) {
    parts.push(manualNotes.trim());
    parts.push(""); // blank line
  }

  // Add divider if there are entries (or manual notes)
  if (entries.length > 0) {
    if (manualNotes && manualNotes.trim()) {
      parts.push(AUTO_GENERATED_DIVIDER);
      parts.push(""); // blank line
    }

    // Add each entry
    entries.forEach((entry, index) => {
      parts.push(entry.date);
      entry.items.forEach((item) => {
        parts.push(`- ${item}`);
      });
      // Add blank line between entries (but not after the last one)
      if (index < entries.length - 1) {
        parts.push("");
      }
    });
  }

  return parts.join("\n");
}

/**
 * Add or update history entry for a specific meeting date
 * Returns the updated history string
 */
function updateHistoryForDate(
  existingHistory: string | null | undefined,
  meetingDate: string, // MM/DD/YYYY format
  newItems: string[]
): string {
  // Parse existing history
  const { manualNotes, entries } = parseHistoryString(existingHistory);

  // Check if entry for this date already exists
  const existingIndex = entries.findIndex((e) => e.date === meetingDate);

  if (existingIndex >= 0) {
    // Replace existing entry
    entries[existingIndex] = { date: meetingDate, items: newItems };
  } else {
    // Add new entry
    entries.push({ date: meetingDate, items: newItems });
  }

  // Sort by date (newest first)
  entries.sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateB.getTime() - dateA.getTime();
  });

  // Rebuild formatted string
  return formatHistoryEntries(manualNotes, entries);
}

/**
 * Main function to append Gong call insights to opportunity history
 * Updates painPointsHistory, goalsHistory, and nextStepsHistory fields
 * Tracks parsed calls to prevent duplicate entries
 */
export async function appendToOpportunityHistory({
  opportunityId,
  gongCallId,
  meetingDate,
  painPoints = [],
  goals = [],
  nextSteps = [],
}: {
  opportunityId: string;
  gongCallId: string;
  meetingDate: Date | string;
  painPoints?: string[];
  goals?: string[];
  nextSteps?: string[];
}) {
  // Format meeting date to US format
  const formattedDate = formatDateUS(meetingDate);

  // Fetch current opportunity
  const opportunity = await prisma.opportunity.findUnique({
    where: { id: opportunityId },
    select: {
      painPointsHistory: true,
      goalsHistory: true,
      nextStepsHistory: true,
      parsedGongCallIds: true,
    },
  });

  if (!opportunity) {
    throw new Error(`Opportunity not found: ${opportunityId}`);
  }

  // Check if this call has already been parsed
  if (opportunity.parsedGongCallIds.includes(gongCallId)) {
    console.log(`[gong-history] Call ${gongCallId} already parsed for opportunity ${opportunityId}, skipping duplicate`);
    return opportunity; // Return existing opportunity without changes
  }

  // Update each history field
  const updatedPainPointsHistory = updateHistoryForDate(
    opportunity.painPointsHistory,
    formattedDate,
    painPoints
  );

  const updatedGoalsHistory = updateHistoryForDate(
    opportunity.goalsHistory,
    formattedDate,
    goals
  );

  const updatedNextStepsHistory = updateHistoryForDate(
    opportunity.nextStepsHistory,
    formattedDate,
    nextSteps
  );

  // Save to database and track this parsed call
  const updatedOpportunity = await prisma.opportunity.update({
    where: { id: opportunityId },
    data: {
      painPointsHistory: updatedPainPointsHistory,
      goalsHistory: updatedGoalsHistory,
      nextStepsHistory: updatedNextStepsHistory,
      parsedGongCallIds: {
        push: gongCallId, // Add this call ID to the tracking array
      },
    },
  });

  console.log(`[gong-history] Successfully updated opportunity ${opportunityId} with insights from call ${gongCallId}`);

  return updatedOpportunity;
}
