/**
 * Migration Script: Fix History Sort Order
 *
 * This script re-parses and re-sorts all painPointsHistory, goalsHistory,
 * and nextStepsHistory fields to ensure entries are in chronological order
 * (newest first).
 *
 * Run with: npx tsx scripts/fix-history-sort-order.ts
 */

import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// Divider line to separate manual notes from auto-generated entries
const AUTO_GENERATED_DIVIDER = "--- Auto-generated from calls ---";

// Date format regex for US format: MM/DD/YYYY
const DATE_REGEX = /^(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/\d{4}$/;

interface HistoryEntry {
  date: string; // MM/DD/YYYY format
  items: string[];
}

interface ParsedHistory {
  manualNotes: string;
  entries: HistoryEntry[];
}

/**
 * Parse a history string into structured format
 * Handles both old format (without divider) and new format (with divider)
 */
function parseHistoryString(historyText: string | null | undefined): ParsedHistory {
  if (!historyText || historyText.trim() === "") {
    return { manualNotes: "", entries: [] };
  }

  const lines = historyText.split("\n");
  const entries: HistoryEntry[] = [];
  let currentEntry: HistoryEntry | null = null;
  let inAutoGeneratedSection = false;
  const manualNotesLines: string[] = [];
  let foundFirstDate = false;

  for (const line of lines) {
    const trimmedLine = line.trim();

    // Check for divider
    if (trimmedLine === AUTO_GENERATED_DIVIDER) {
      inAutoGeneratedSection = true;
      continue;
    }

    // Check if this line is a date header
    if (DATE_REGEX.test(trimmedLine)) {
      // If we haven't seen the divider but this is a date, treat everything
      // from here as auto-generated (handles old format without divider)
      if (!inAutoGeneratedSection && !foundFirstDate) {
        // Everything before this was manual notes
        inAutoGeneratedSection = true;
        foundFirstDate = true;
      }

      // Save previous entry if exists
      if (currentEntry) {
        entries.push(currentEntry);
      }
      // Start new entry
      currentEntry = { date: trimmedLine, items: [] };
      continue;
    }

    // If we haven't hit a date yet and no divider, treat as manual notes
    if (!inAutoGeneratedSection && !foundFirstDate) {
      manualNotesLines.push(line);
      continue;
    }

    // Check if this line is a bullet point
    if (currentEntry && trimmedLine.startsWith("-")) {
      const item = trimmedLine.substring(1).trim();
      if (item) {
        currentEntry.items.push(item);
      }
    }
  }

  // Save last entry
  if (currentEntry) {
    entries.push(currentEntry);
  }

  // Clean up manual notes - remove trailing content that was actually date entries
  // (happens when old format had no divider)
  let manualNotes = manualNotesLines.join("\n").trim();

  // If manual notes looks like it contains date entries (old format issue),
  // try to extract them
  if (manualNotes && DATE_REGEX.test(manualNotes.split("\n")[0]?.trim() || "")) {
    // The "manual notes" is actually old format data without divider
    // Re-parse it as entries
    const oldFormatParsed = parseOldFormatHistory(manualNotes);
    entries.unshift(...oldFormatParsed);
    manualNotes = "";
  }

  return { manualNotes, entries };
}

/**
 * Parse old format history (no divider, just dates and bullets)
 */
function parseOldFormatHistory(historyText: string): HistoryEntry[] {
  const lines = historyText.split("\n");
  const entries: HistoryEntry[] = [];
  let currentEntry: HistoryEntry | null = null;

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (DATE_REGEX.test(trimmedLine)) {
      if (currentEntry) {
        entries.push(currentEntry);
      }
      currentEntry = { date: trimmedLine, items: [] };
      continue;
    }

    if (currentEntry && trimmedLine.startsWith("-")) {
      const item = trimmedLine.substring(1).trim();
      if (item) {
        currentEntry.items.push(item);
      }
    }
  }

  if (currentEntry) {
    entries.push(currentEntry);
  }

  return entries;
}

/**
 * Format structured history entries back into a string
 */
function formatHistoryEntries(manualNotes: string, entries: HistoryEntry[]): string {
  const parts: string[] = [];

  // Add manual notes if present
  if (manualNotes && manualNotes.trim()) {
    parts.push(manualNotes.trim());
    parts.push(""); // blank line
  }

  // Add divider and entries
  if (entries.length > 0) {
    // Always add divider before auto-generated entries
    parts.push(AUTO_GENERATED_DIVIDER);
    parts.push(""); // blank line

    // Add each entry
    entries.forEach((entry, index) => {
      parts.push(entry.date);
      entry.items.forEach((item) => {
        parts.push(`- ${item}`);
      });
      // Add blank line between entries (but not after the last one)
      if (index < entries.length - 1) {
        parts.push("");
      }
    });
  }

  return parts.join("\n");
}

/**
 * Sort entries by date (newest first)
 */
function sortEntries(entries: HistoryEntry[]): HistoryEntry[] {
  return [...entries].sort((a, b) => {
    // Parse MM/DD/YYYY format
    const [aMonth, aDay, aYear] = a.date.split("/").map(Number);
    const [bMonth, bDay, bYear] = b.date.split("/").map(Number);

    // Compare year first, then month, then day
    if (aYear !== bYear) return bYear - aYear;
    if (aMonth !== bMonth) return bMonth - aMonth;
    return bDay - aDay;
  });
}

/**
 * Re-sort a history field
 */
function resortHistoryField(historyText: string | null | undefined): string | null {
  if (!historyText || historyText.trim() === "") {
    return null;
  }

  const { manualNotes, entries } = parseHistoryString(historyText);

  if (entries.length === 0) {
    // No entries to sort, return as-is (just manual notes)
    return historyText;
  }

  // Sort entries newest first
  const sortedEntries = sortEntries(entries);

  // Rebuild formatted string
  return formatHistoryEntries(manualNotes, sortedEntries);
}

async function main() {
  console.log("Starting history sort order fix...\n");

  // Find all opportunities with any history field populated
  const opportunities = await prisma.opportunity.findMany({
    where: {
      OR: [
        { painPointsHistory: { not: null } },
        { goalsHistory: { not: null } },
        { nextStepsHistory: { not: null } },
      ],
    },
    select: {
      id: true,
      name: true,
      painPointsHistory: true,
      goalsHistory: true,
      nextStepsHistory: true,
    },
  });

  console.log(`Found ${opportunities.length} opportunities with history fields\n`);

  let updatedCount = 0;
  let skippedCount = 0;

  for (const opp of opportunities) {
    const updates: {
      painPointsHistory?: string | null;
      goalsHistory?: string | null;
      nextStepsHistory?: string | null;
    } = {};

    let hasChanges = false;

    // Process painPointsHistory
    if (opp.painPointsHistory) {
      const resorted = resortHistoryField(opp.painPointsHistory);
      if (resorted !== opp.painPointsHistory) {
        updates.painPointsHistory = resorted;
        hasChanges = true;
      }
    }

    // Process goalsHistory
    if (opp.goalsHistory) {
      const resorted = resortHistoryField(opp.goalsHistory);
      if (resorted !== opp.goalsHistory) {
        updates.goalsHistory = resorted;
        hasChanges = true;
      }
    }

    // Process nextStepsHistory
    if (opp.nextStepsHistory) {
      const resorted = resortHistoryField(opp.nextStepsHistory);
      if (resorted !== opp.nextStepsHistory) {
        updates.nextStepsHistory = resorted;
        hasChanges = true;
      }
    }

    if (hasChanges) {
      await prisma.opportunity.update({
        where: { id: opp.id },
        data: updates,
      });
      console.log(`âœ“ Updated: ${opp.name} (${opp.id})`);
      updatedCount++;
    } else {
      console.log(`- Skipped (no changes): ${opp.name}`);
      skippedCount++;
    }
  }

  console.log("\n========================================");
  console.log(`Migration complete!`);
  console.log(`  Updated: ${updatedCount} opportunities`);
  console.log(`  Skipped: ${skippedCount} opportunities`);
  console.log("========================================");
}

main()
  .catch((e) => {
    console.error("Migration failed:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });